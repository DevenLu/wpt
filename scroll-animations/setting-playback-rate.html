<!DOCTYPE html>
<meta charset=utf-8>
<title>Setting the playback rate of an animation that is using a ScrollTimeline</title>
<link rel="help" href="https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../web-animations/testcommon.js"></script>
<style>
.scroller {
  overflow: auto;
  height: 100px;
  width: 100px;
}
.contents {
  height: 1000px;
  width: 100%;
}
</style>
<body>
<div id="log"></div>
<script>
'use strict';

  function createScroller(test) {
    var scroller = createDiv(test);
    scroller.innerHTML = "<div class='contents'></div>";
    scroller.classList.add('scroller');
    return scroller;
  }

  function createScrollTimeline(test) {
    return new ScrollTimeline({
      scrollSource: createScroller(test),
      timeRange: 1000
    });
  }

  function createScrollLinkedAnimation(test, timeline) {
    if(timeline === undefined)
      timeline = createScrollTimeline(test);
    const DURATION = 1000; // ms
    const KEYFRAMES = { opacity: [1, 0] };
    return new Animation(
      new KeyframeEffect(createDiv(test), KEYFRAMES, DURATION), timeline);
  }

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    // this forces a layout which results in an active timeline
    scroller.scrollTop = 0;

    animation.playbackRate = 0.5;
    animation.play();

    assert_equals(animation.currentTime, 0,
      'Zero current time is not affected by playbackRate.');
  }, 'Zero current time is not affected by playbackRate set while the ' +
       'animation is in idle state.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    // this forces a layout which results in an active timeline
    scroller.scrollTop = 0;

    animation.play();
    animation.playbackRate = 0.5;

    assert_equals(animation.currentTime, 0,
      'Zero current time is not affected by playbackRate.');
  }, 'Zero current time is not affected by playbackRate set while the ' +
      'animation is in play-pending state.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    const timeRange = animation.timeline.timeRange;
    scroller.scrollTop = 0.2 * maxScroll;

    animation.playbackRate = 0.5;
    animation.play();
    await animation.ready;
    assert_equals(animation.currentTime, 0.2 * timeRange * 0.5,
      'Initial current time is scaled by playbackRate.');
  }, 'Initial current time is scaled by playbackRate set while ' +
      'scroll-linked animation is in running state.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    const timeRange = animation.timeline.timeRange;
    const playbackRate = 2;

    scroller.scrollTop = 0.2 * maxScroll;

    animation.play();
    await animation.ready;
    // Set playback rate while the animation is playing.
    animation.playbackRate = playbackRate;
    assert_times_equal(animation.currentTime, 0.2 * timeRange,
      'The current time should stay unaffected by setting playback rate.');
  }, 'The current time is not affected by playbackRate set while the ' +
      'scroll-linked animation is in play state.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    const timeRange = animation.timeline.timeRange;
    const playbackRate = 2;

    // Set playback rate while the animation is in 'idle' state.
    animation.playbackRate = playbackRate;
    animation.play();
    await animation.ready;
    scroller.scrollTop = 0.2 * maxScroll;

    assert_times_equal(animation.currentTime, 0.2 * timeRange * playbackRate,
      'The current time should increase two times faster than timeline.');
  }, 'The playback rate set before scroll-linked animation started playing ' +
      'affects the rate of progress of the current time');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    animation.play();

    await animation.ready;

    animation.playbackRate = 2;
    scroller.scrollTop = 0.25 * maxScroll;

    assert_times_equal(
      animation.currentTime,
      animation.timeline.currentTime * animation.playbackRate,
      'The current time should increase two times faster than timeline'
    );
  }, 'The playback rate affects the rate of progress of the current time' +
    ' when scrolling');

  test(t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.25 * maxScroll;
    animation.play();

    animation.playbackRate = 2;

    assert_equals(animation.playState, "running");
    assert_true(animation.pending);
    assert_times_equal(animation.currentTime, animation.timeline.currentTime);
  }, 'Setting the playback rate while play-pending preserves the current time' +
    ' from scrollTimeline.');

  test(t => {
    const animation = createScrollLinkedAnimation(t);
    animation.play();
    const test_value = 250;
    animation.currentTime = test_value;
    animation.playbackRate = 2;

    assert_equals(animation.playState, "running");
    assert_true(animation.pending);
    assert_times_equal(animation.currentTime, test_value);
  }, 'Setting the playback rate while play-pending preserves the set current' +
    ' time.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.25 * maxScroll;
    animation.play();

    await animation.ready;
    animation.playbackRate = 2;

    assert_times_equal(animation.currentTime, animation.timeline.currentTime);
  }, 'Setting the playback rate while playing preserves the current time' +
    ' from scrollTimeline.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);

    /* Wait for animation frame is here for now to avoid a renderer crash
    caused by crbug.com/1042924. Once that is fixed, these can be removed */
    await waitForAnimationFrames(2);

    const test_value = 250;
    animation.play();

    animation.currentTime = test_value;
    await animation.ready;
    animation.playbackRate = 2;

    assert_times_equal(animation.currentTime, test_value);
  }, 'Setting the playback rate while playing preserves the set current time.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    const range = animation.timeline.timeRange;
    animation.playbackRate = -1;
    scroller.scrollTop = 0.3 * maxScroll;
    animation.play();

    await animation.ready;
    const expectedCurrentTime = range - animation.timeline.currentTime;
    assert_times_equal(animation.currentTime, expectedCurrentTime);
  }, 'Negative initial playback rate should correctly modify initial current' +
    ' time.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.5 * maxScroll;
    animation.play();

    await animation.ready;
    const startingTimelineCurrentTime = animation.timeline.currentTime;
    const startingCurrentTime = animation.currentTime;
    assert_times_equal(startingCurrentTime, startingTimelineCurrentTime);
    animation.playbackRate = -1;

    scroller.scrollTop = 0.8 * maxScroll;
    let timelineDiff =
      startingTimelineCurrentTime - animation.timeline.currentTime;
    let expectedCurrentTime = startingCurrentTime + timelineDiff;
    assert_times_equal(animation.currentTime, expectedCurrentTime);

    scroller.scrollTop = 0.2 * maxScroll;
    timelineDiff = startingTimelineCurrentTime - animation.timeline.currentTime;
    expectedCurrentTime = startingCurrentTime + timelineDiff;
    assert_times_equal(animation.currentTime, expectedCurrentTime);
  }, 'Reversing the playback rate while playing correctly impacts current' +
    ' time during future scrolls');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    const range = animation.timeline.timeRange;
    animation.playbackRate = 0;
    scroller.scrollTop = 0.3 * maxScroll;
    animation.play();

    await animation.ready;
    assert_times_equal(animation.currentTime, 0);
  }, 'Zero initial playback rate should correctly modify initial current' +
    ' time.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.2 * maxScroll;
    animation.play();

    await animation.ready;
    assert_times_equal(animation.currentTime, 200);
    animation.playbackRate = 0;
    scroller.scrollTop = 0.5 * maxScroll;

    // Ensure that current time does not change.
    assert_time_equals_literal(animation.timeline.currentTime, 500);
    assert_time_equals_literal(animation.currentTime, 200);
  }, 'Setting a zero playback rate while running preserves the current time');
</script>
</body>
